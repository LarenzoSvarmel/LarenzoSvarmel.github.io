<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Skate Sim with Skeleton + Ollie + Gamepad</title>
  <style>
    body { margin: 0; overflow: hidden; background: #202030; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #ddd; font-family: monospace; user-select:none;
      background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;
    }
  </style>
</head>
<body>
<div id="info">Use WASD + Space or Xbox Controller<br>Flick right stick UP for Ollie</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202030);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 5, 10);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Ground plane
  const groundMat = new THREE.MeshStandardMaterial({color: 0x444455});
  const groundGeom = new THREE.PlaneGeometry(100, 100);
  const ground = new THREE.Mesh(groundGeom, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Skateboard (simple box)
  const boardMat = new THREE.MeshStandardMaterial({color: 0xffcc00});
  const boardGeom = new THREE.BoxGeometry(3, 0.1, 1);
  const board = new THREE.Mesh(boardGeom, boardMat);
  board.position.y = 0.2;
  scene.add(board);

  // === Skeleton Skater ===
  const skeletonGroup = new THREE.Group();

  // Helper to create bones as lines between two points
  function createBone(start, end) {
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      ...start.toArray(),
      ...end.toArray()
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const material = new THREE.LineBasicMaterial({color: 0x3399ff, linewidth: 3});
    return new THREE.Line(geometry, material);
  }

  // Basic joint positions (relative to skater origin)
  const joints = {
    pelvis: new THREE.Vector3(0, 1, 0),
    spine: new THREE.Vector3(0, 1.4, 0),
    head: new THREE.Vector3(0, 1.8, 0),
    leftShoulder: new THREE.Vector3(-0.3, 1.5, 0),
    rightShoulder: new THREE.Vector3(0.3, 1.5, 0),
    leftElbow: new THREE.Vector3(-0.6, 1.2, 0),
    rightElbow: new THREE.Vector3(0.6, 1.2, 0),
    leftHand: new THREE.Vector3(-0.7, 0.9, 0),
    rightHand: new THREE.Vector3(0.7, 0.9, 0),
    leftHip: new THREE.Vector3(-0.2, 0.8, 0),
    rightHip: new THREE.Vector3(0.2, 0.8, 0),
    leftKnee: new THREE.Vector3(-0.2, 0.4, 0),
    rightKnee: new THREE.Vector3(0.2, 0.4, 0),
    leftFoot: new THREE.Vector3(-0.2, 0.1, 0.1),
    rightFoot: new THREE.Vector3(0.2, 0.1, 0.1),
  };

  // Create bones
  const bones = [];
  function addBone(a,b){ bones.push(createBone(joints[a], joints[b])); }
  addBone('pelvis', 'spine');
  addBone('spine', 'head');
  addBone('spine', 'leftShoulder');
  addBone('spine', 'rightShoulder');
  addBone('leftShoulder', 'leftElbow');
  addBone('rightShoulder', 'rightElbow');
  addBone('leftElbow', 'leftHand');
  addBone('rightElbow', 'rightHand');
  addBone('pelvis', 'leftHip');
  addBone('pelvis', 'rightHip');
  addBone('leftHip', 'leftKnee');
  addBone('rightHip', 'rightKnee');
  addBone('leftKnee', 'leftFoot');
  addBone('rightKnee', 'rightFoot');

  bones.forEach(b => skeletonGroup.add(b));
  skeletonGroup.position.y = 0.7; // sit skater on board roughly
  scene.add(skeletonGroup);

  // Attach skeletonGroup to board so it moves with it
  board.add(skeletonGroup);
  skeletonGroup.position.set(0, 0.5, 0);

  // Physics & movement
  let velocity = new THREE.Vector3(0, 0, 0);
  const gravity = -9.8;
  let onGround = true;

  // Trick state
  let isOllie = false;
  let ollieTimer = 0;
  const ollieDuration = 0.5; // seconds

  // Keyboard controls
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.code] = true; });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  // Gamepad support
  let gamepadIndex = null;
  let lastRightStickY = 0;
  const flickThreshold = 0.7;
  let flickCooldown = 0;

  window.addEventListener("gamepadconnected", (e) => {
    gamepadIndex = e.gamepad.index;
    console.log("Gamepad connected at index", gamepadIndex);
  });
  window.addEventListener("gamepaddisconnected", (e) => {
    if(e.gamepad.index === gamepadIndex) gamepadIndex = null;
    console.log("Gamepad disconnected");
  });

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Camera follow offsets
  const cameraTargetOffset = new THREE.Vector3(0, 2.5, -6);
  const cameraLookAtOffset = new THREE.Vector3(0, 1.2, 0);

  // Clock for timing
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // === INPUT ===

    // Keyboard forward/backward
    if(keys['KeyW']) {
      velocity.z -= 10 * delta;
    } else if(keys['KeyS']) {
      velocity.z += 8 * delta;
    } else {
      velocity.z *= 0.95;
    }

    // Keyboard rotate
    if(keys['KeyA']) board.rotation.y += 2 * delta;
    if(keys['KeyD']) board.rotation.y -= 2 * delta;

    // Keyboard jump (ollie)
    if(keys['Space'] && onGround && !isOllie) {
      startOllie();
    }

    // === GAMEPAD ===
    if(gamepadIndex !== null){
      const gp = navigator.getGamepads()[gamepadIndex];
      if(gp){

        // Left stick: movement
        const lx = gp.axes[0]; // left stick X
        const ly = gp.axes[1]; // left stick Y
        // Deadzone
        if(Math.abs(ly) > 0.2){
          velocity.z -= ly * 10 * delta;
        } else {
          velocity.z *= 0.95;
        }
        if(Math.abs(lx) > 0.2){
          board.rotation.y -= lx * 2 * delta;
        }

        // Right stick flick UP for ollie
        const ry = gp.axes[3];
        // Detect flick upward
        if(flickCooldown <= 0){
          if(lastRightStickY > -flickThreshold && ry <= -flickThreshold && onGround && !isOllie){
            startOllie();
            flickCooldown = 0.3; // cooldown in seconds
          }
        }
        lastRightStickY = ry;

        // Button A (0) for ollie as well
        if(gp.buttons[0].pressed && onGround && !isOllie){
          startOllie();
        }
      }
    }

    if(flickCooldown > 0){
      flickCooldown -= delta;
    }

    // === PHYSICS ===

    if(isOllie){
      ollieTimer += delta;
      // Simple upward movement during ollie
      const ollieHeight = 1.5;
      // Parabolic motion up and down
      const t = ollieTimer / ollieDuration;
      const height = ollieHeight * 4 * t * (1 - t); // parabola from 0 to 1 back to 0
      board.position.y = 0.2 + height;
      if(ollieTimer >= ollieDuration){
        isOllie = false;
        ollieTimer = 0;
        board.position.y = 0.2;
        velocity.y = 0;
        onGround = true;
      }
    } else {
      // Normal gravity
      velocity.y += gravity * delta;
      board.position.y += velocity.y * delta;
      if(board.position.y < 0.2){
        board.position.y = 0.2;
        velocity.y = 0;
        onGround = true;
      }
    }

    // Move board based on velocity and rotation
    board.position.x += Math.sin(board.rotation.y) * velocity.z * delta;
    board.position.z += Math.cos(board.rotation.y) * velocity.z * delta;

    // Camera follow smooth lerp
    const desiredCamPos = board.position.clone().add(cameraTargetOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), board.rotation.y));
    camera.position.lerp(desiredCamPos, 0.1);
    const lookAtPos = board.position.clone().add(cameraLookAtOffset);
    camera.lookAt(lookAtPos);

    renderer.render(scene, camera);
  }

  // Start ollie trick
  function startOllie(){
    isOllie = true;
    ollieTimer = 0;
    onGround = false;
    velocity.y = 5;
  }

  animate();
</script>
</body>
</html>
