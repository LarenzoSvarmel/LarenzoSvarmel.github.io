<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skateboard Physics with Three.js & Cannon-es</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Physics world
    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);

    // Ground body
    const groundMaterial = new CANNON.Material('ground');
    const groundBody = new CANNON.Body({
      mass: 0,
      shape: new CANNON.Plane(),
      material: groundMaterial,
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // Ground mesh
    const groundGeo = new THREE.PlaneGeometry(100, 100);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const groundMesh = new THREE.Mesh(groundGeo, groundMat);
    groundMesh.rotation.x = -Math.PI / 2;
    scene.add(groundMesh);

    // Skateboard body
    const boardShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.05, 0.5));
    const boardBody = new CANNON.Body({
      mass: 2,
      shape: boardShape,
      position: new CANNON.Vec3(0, 1, 0),
    });
    world.addBody(boardBody);

    // Skateboard mesh
    const boardGeo = new THREE.BoxGeometry(3, 0.1, 1);
    const boardMat = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
    const boardMesh = new THREE.Mesh(boardGeo, boardMat);
    scene.add(boardMesh);

    // Feet bodies
    const footRadius = 0.1;
    const frontFootBody = new CANNON.Body({
      mass: 0.5,
      shape: new CANNON.Sphere(footRadius),
      position: new CANNON.Vec3(0, 1.2, 1.2),
    });
    const backFootBody = new CANNON.Body({
      mass: 0.5,
      shape: new CANNON.Sphere(footRadius),
      position: new CANNON.Vec3(0, 1.2, -1.2),
    });
    world.addBody(frontFootBody);
    world.addBody(backFootBody);

    // Feet meshes
    const footGeo = new THREE.SphereGeometry(footRadius, 32, 32);
    const frontFootMesh = new THREE.Mesh(
      footGeo,
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    const backFootMesh = new THREE.Mesh(
      footGeo,
      new THREE.MeshStandardMaterial({ color: 0x0000ff })
    );
    scene.add(frontFootMesh);
    scene.add(backFootMesh);

    // Constraints between board and feet
    const frontConstraint = new CANNON.PointToPointConstraint(
      boardBody,
      new CANNON.Vec3(0, 0, 1.2),
      frontFootBody,
      new CANNON.Vec3(0, 0, 0)
    );
    const backConstraint = new CANNON.PointToPointConstraint(
      boardBody,
      new CANNON.Vec3(0, 0, -1.2),
      backFootBody,
      new CANNON.Vec3(0, 0, 0)
    );
    world.addConstraint(frontConstraint);
    world.addConstraint(backConstraint);

    // Gamepad input handler
    function handleGamepadInput() {
      const gamepads = navigator.getGamepads();
      if (!gamepads || !gamepads[0]) return;

      const gp = gamepads[0];
      const leftY = gp.axes[1];
      const rightY = gp.axes[3];
      const force = 5;

      if (Math.abs(leftY) > 0.1) {
        backFootBody.applyForce(
          new CANNON.Vec3(0, -leftY * force, 0),
          backFootBody.position
        );
      }
      if (Math.abs(rightY) > 0.1) {
        frontFootBody.applyForce(
          new CANNON.Vec3(0, -rightY * force, 0),
          frontFootBody.position
        );
      }
    }

    // Camera setup
    camera.position.set(0, 3, 7);
    camera.lookAt(0, 1, 0);

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      world.step(1 / 60);
      handleGamepadInput();

      // Sync physics bodies to Three.js meshes
      boardMesh.position.copy(boardBody.position);
      boardMesh.quaternion.copy(boardBody.quaternion);

      frontFootMesh.position.copy(frontFootBody.position);
      frontFootMesh.quaternion.copy(frontFootBody.quaternion);

      backFootMesh.position.copy(backFootBody.position);
      backFootMesh.quaternion.copy(backFootBody.quaternion);

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
