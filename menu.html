<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skateboard Physics Setup + Release</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);
scene.add(new THREE.AmbientLight(0x404040));

const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

const groundMat = new CANNON.Material('ground');
const groundBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane(),
  material: groundMat,
});
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

const groundGeo = new THREE.PlaneGeometry(100, 100);
const groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x444444 }));
groundMesh.rotation.x = -Math.PI / 2;
scene.add(groundMesh);

const boardShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.025, 1.5));
const boardBody = new CANNON.Body({ mass: 2, shape: boardShape, position: new CANNON.Vec3(0, 1, 0) });
world.addBody(boardBody);

const boardMesh = new THREE.Mesh(
  new THREE.BoxGeometry(1, 0.05, 3),
  new THREE.MeshStandardMaterial({ color: 0xffcc00 })
);
scene.add(boardMesh);

const footRadius = 0.12;
function createFoot(position) {
  const body = new CANNON.Body({
    mass: 0.5,
    shape: new CANNON.Sphere(footRadius),
    position: position.clone(),
    linearDamping: 0.9,
    angularDamping: 0.9,
    fixedRotation: true,
  });
  world.addBody(body);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(footRadius, 32, 32),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
  );
  scene.add(mesh);

  return { body, mesh };
}

const frontFootStartPos = new CANNON.Vec3(0, 1 + 0.025 + footRadius, 1.4);
const backFootStartPos = new CANNON.Vec3(0, 1 + 0.025 + footRadius, -1.4);

const frontFoot = createFoot(frontFootStartPos);
const backFoot = createFoot(backFootStartPos);
backFoot.mesh.material.color.set(0x0000ff);

const frontConstraint = new CANNON.PointToPointConstraint(
  boardBody,
  new CANNON.Vec3(0, 0, 1.4),
  frontFoot.body,
  new CANNON.Vec3(0, 0, 0)
);
const backConstraint = new CANNON.PointToPointConstraint(
  boardBody,
  new CANNON.Vec3(0, 0, -1.4),
  backFoot.body,
  new CANNON.Vec3(0, 0, 0)
);
world.addConstraint(frontConstraint);
world.addConstraint(backConstraint);

// Foot control points relative to board local space
// front foot points: left edge, right edge, top (nose), bottom (pocket)
// back foot points mirrored left/right
const footControlPoints = {
  front: {
    left: new THREE.Vector3(-0.5, 0, 1.5),
    right: new THREE.Vector3(0.5, 0, 1.5),
    top: new THREE.Vector3(0, 0, 1.5),
    bottom: new THREE.Vector3(0, 0, 1.1),
  },
  back: {
    left: new THREE.Vector3(0.5, 0, -1.5),  // mirrored left/right
    right: new THREE.Vector3(-0.5, 0, -1.5),
    top: new THREE.Vector3(0, 0, -1.5),
    bottom: new THREE.Vector3(0, 0, -1.1),
  },
};

// States for setup and release
let setupFront = null; // THREE.Vector3 local target or null
let setupBack = null;

let leftStickPos = new THREE.Vector2(0, 0);
let rightStickPos = new THREE.Vector2(0, 0);
let leftStickActive = false;
let rightStickActive = false;
let leftStickPrevActive = false;
let rightStickPrevActive = false;

function getFootTargetPoint(foot, stickPos) {
  const deadzone = 0.15;
  if (stickPos.length() < deadzone) return null;

  let horiz = stickPos.x;
  let vert = stickPos.y;

  const verticalPointName = vert > 0 ? 'top' : 'bottom';
  const horizontalPointName = horiz < 0 ? 'left' : 'right';

  const absHoriz = Math.abs(horiz);
  const absVert = Math.abs(vert);
  const total = absHoriz + absVert;

  if (total === 0) return null;

  const vertWeight = absVert / total;
  const horizWeight = absHoriz / total;

  const footPoints = footControlPoints[foot];
  const target = new THREE.Vector3();
  target.copy(footPoints[verticalPointName]).multiplyScalar(vertWeight);
  target.addScaledVector(footPoints[horizontalPointName], horizWeight);

  return target;
}

// When in setup mode, feet move smoothly to their local setup positions, but no forces on board yet.
// On release, constraints remove and board/feet physics react.

function updateFeetSetupPositions() {
  // Front foot setup
  if (setupFront) {
    const quat = new THREE.Quaternion().copy(boardBody.quaternion);
    const boardPos = new THREE.Vector3().copy(boardBody.position);
    const worldTarget = setupFront.clone().applyQuaternion(quat).add(boardPos);
    worldTarget.y = boardBody.position.y + 0.025 + footRadius + 0.01;

    frontFoot.body.position.lerp(new CANNON.Vec3(worldTarget.x, worldTarget.y, worldTarget.z), 0.2);
    frontFoot.body.velocity.set(0, 0, 0);
    frontFoot.body.angularVelocity.set(0, 0, 0);
  }

  // Back foot setup
  if (setupBack) {
    const quat = new THREE.Quaternion().copy(boardBody.quaternion);
    const boardPos = new THREE.Vector3().copy(boardBody.position);
    const worldTarget = setupBack.clone().applyQuaternion(quat).add(boardPos);
    worldTarget.y = boardBody.position.y + 0.025 + footRadius + 0.01;

    backFoot.body.position.lerp(new CANNON.Vec3(worldTarget.x, worldTarget.y, worldTarget.z), 0.2);
    backFoot.body.velocity.set(0, 0, 0);
    backFoot.body.angularVelocity.set(0, 0, 0);
  }
}

function onStickRelease(foot) {
  // Remove constraint to free foot
  if (foot === 'front' && world.constraints.includes(frontConstraint)) {
    world.removeConstraint(frontConstraint);
  }
  if (foot === 'back' && world.constraints.includes(backConstraint)) {
    world.removeConstraint(backConstraint);
  }

  const footObj = foot === 'front' ? frontFoot : backFoot;

  // Calculate impulse for feet: upward and slightly outward from board center
  const impulseStrength = 3;
  const dir = new CANNON.Vec3().copy(footObj.body.position).vsub(boardBody.position);
  dir.y = 0;
  dir.normalize();

  const impulse = new CANNON.Vec3(dir.x * impulseStrength * 0.5, impulseStrength, dir.z * impulseStrength * 0.5);
  footObj.body.applyImpulse(impulse, footObj.body.position);

  // Board reacts with opposite impulse
  const boardImpulse = impulse.scale(-0.5);
  boardBody.applyImpulse(boardImpulse, boardBody.position);

  // Clear setup for that foot (no longer "holding")
  if (foot === 'front') setupFront = null;
  else setupBack = null;

  // After ~1.2 seconds, land foot back onto board and re-add constraint
  setTimeout(() => {
    let localPos = foot === 'front' ? frontFootStartPos : backFootStartPos;
    footObj.body.position.set(localPos.x, localPos.y, localPos.z);
    footObj.body.velocity.set(0, 0, 0);
    footObj.body.angularVelocity.set(0, 0, 0);

    if (foot === 'front' && !world.constraints.includes(frontConstraint)) {
      world.addConstraint(frontConstraint);
    }
    if (foot === 'back' && !world.constraints.includes(backConstraint)) {
      world.addConstraint(backConstraint);
    }
  }, 1200);
}

function pollGamepads() {
  const gp = navigator.getGamepads()[0];
  if (!gp) {
    leftStickActive = false;
    rightStickActive = false;
    return;
  }
  leftStickPos.set(gp.axes[0], -gp.axes[1]);
  rightStickPos.set(gp.axes[2], -gp.axes[3]);

  leftStickActive = leftStickPos.length() > 0.15;
  rightStickActive = rightStickPos.length() > 0.15;

  // Setup feet positions while holding sticks
  if (rightStickActive) {
    const target = getFootTargetPoint('front', rightStickPos);
    if (target) setupFront = target;
  }
  if (leftStickActive) {
    const target = getFootTargetPoint('back', leftStickPos);
    if (target) setupBack = target;
  }

  // On stick release, trigger pop
  if (!rightStickActive && rightStickPrevActive) onStickRelease('front');
  if (!leftStickActive && leftStickPrevActive) onStickRelease('back');

  rightStickPrevActive = rightStickActive;
  leftStickPrevActive = leftStickActive;
}

camera.position.set(0, 3, 7);
camera.lookAt(0, 1, 0);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

const camTarget = new THREE.Vector3();
const camOffset = new THREE.Vector3(0, 3, 6);

function animate() {
  requestAnimationFrame(animate);

  pollGamepads();
  updateFeetSetupPositions();

  world.step(1 / 60);

  boardMesh.position.copy(boardBody.position);
  boardMesh.quaternion.copy(boardBody.quaternion);

  frontFoot.mesh.position.copy(frontFoot.body.position);
  frontFoot.mesh.quaternion.copy(frontFoot.body.quaternion);

  backFoot.mesh.position.copy(backFoot.body.position);
  backFoot.mesh.quaternion.copy(backFoot.body.quaternion);

  camTarget.copy(boardMesh.position);
  let offset = camOffset.clone().applyQuaternion(boardMesh.quaternion);
  camera.position.lerp(boardMesh.position.clone().add(offset), 0.1);
  camera.lookAt(camTarget);

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
