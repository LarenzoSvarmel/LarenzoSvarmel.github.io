<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Skateboard Physics - Gamepad Only</title>
  <style>
    body { margin: 0; overflow: hidden; background: #202030; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #ddd; font-family: monospace; user-select:none;
      background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;
      max-width: 300px;
    }
  </style>
</head>
<body>
<div id="info">
  Use Xbox Controller:<br>
  Right Trigger (X button) = Move Forward<br>
  Left Stick = Steering Left/Right<br>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/FBXLoader.js"></script>

<script>
  let scene, camera, renderer;
  let board;
  let velocity = 0;
  const maxSpeed = 10;
  const acceleration = 20;
  const deceleration = 10;

  // Gamepad
  let gamepadIndex = null;

  const clock = new THREE.Clock();

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202030);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Ground
    const groundMat = new THREE.MeshStandardMaterial({color: 0x444455});
    const groundGeom = new THREE.PlaneGeometry(100, 100);
    const ground = new THREE.Mesh(groundGeom, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Load FBX skateboard
    const loader = new THREE.FBXLoader();

    loader.load(
      'https://raw.githubusercontent.com/LarenzoSvarmel/LarenzoSvarmel.github.io/main/untitled.fbx',
      (object) => {
        board = object;
        board.scale.set(0.01, 0.01, 0.01);
        board.position.y = 0.2;

        board.traverse(child => {
          if(child.isMesh){
            child.castShadow = true;
            child.receiveShadow = true;
            child.material.side = THREE.DoubleSide;
          }
        });

        scene.add(board);
        console.log('FBX loaded successfully');
      },
      undefined,
      (err) => {
        console.warn('FBX load failed, using fallback box:', err);
        // fallback box if FBX fails
        const boxGeom = new THREE.BoxGeometry(1, 0.1, 0.3);
        const boxMat = new THREE.MeshStandardMaterial({color: 0xff0000});
        board = new THREE.Mesh(boxGeom, boxMat);
        board.position.y = 0.2;
        scene.add(board);
      }
    );

    // Gamepad connection events
    window.addEventListener("gamepadconnected", (e) => {
      gamepadIndex = e.gamepad.index;
      console.log("Gamepad connected at index", gamepadIndex);
    });
    window.addEventListener("gamepaddisconnected", (e) => {
      if(e.gamepad.index === gamepadIndex) gamepadIndex = null;
      console.log("Gamepad disconnected");
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if(!board){
      renderer.render(scene, camera);
      return;
    }

    // Gamepad input
    if(gamepadIndex !== null){
      const gp = navigator.getGamepads()[gamepadIndex];
      if(gp){
        // Right trigger = button 7 on Xbox controller (value 0 to 1)
        const rightTrigger = gp.buttons[7]?.value || 0;

        // Left stick X axis for steering (-1 left, +1 right)
        const leftStickX = gp.axes[0] || 0;

        // Accelerate/decelerate
        if(rightTrigger > 0.1){
          velocity += acceleration * rightTrigger * delta;
          velocity = Math.min(velocity, maxSpeed);
        } else {
          velocity -= deceleration * delta;
          velocity = Math.max(velocity, 0);
        }

        // Steering rotation
        board.rotation.y -= leftStickX * 2 * delta;
      }
    } else {
      // No gamepad, slowly decelerate
      velocity -= deceleration * delta;
      velocity = Math.max(velocity, 0);
    }

    // Move board forward based on rotation and velocity
    board.position.x += Math.sin(board.rotation.y) * velocity * delta;
    board.position.z += Math.cos(board.rotation.y) * velocity * delta;

    // Camera follows board smoothly
    const camOffset = new THREE.Vector3(0, 2.5, -6);
    const camLookAtOffset = new THREE.Vector3(0, 1.2, 0);
    const desiredCamPos = board.position.clone().add(camOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), board.rotation.y));
    camera.position.lerp(desiredCamPos, 0.1);
    camera.lookAt(board.position.clone().add(camLookAtOffset));

    renderer.render(scene, camera);
  }
</script>
</body>
</html>
