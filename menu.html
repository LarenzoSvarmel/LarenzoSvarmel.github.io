<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skateboard Physics with Three.js & Cannon-es</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);

    const groundMaterial = new CANNON.Material('ground');
    const groundBody = new CANNON.Body({
      mass: 0,
      shape: new CANNON.Plane(),
      material: groundMaterial,
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    const groundGeo = new THREE.PlaneGeometry(100, 100);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const groundMesh = new THREE.Mesh(groundGeo, groundMat);
    groundMesh.rotation.x = -Math.PI / 2;
    scene.add(groundMesh);

    // Board shape - dimensions along (x,y,z) as (width, height, length)
    const boardShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.025, 1.5)); // thinner height
    const boardBody = new CANNON.Body({
      mass: 2,
      shape: boardShape,
      position: new CANNON.Vec3(0, 1, 0),
    });
    boardBody.quaternion.setFromEuler(0, 0, 0);
    world.addBody(boardBody);

    const boardGeo = new THREE.BoxGeometry(1, 0.05, 3); // thinner height
    const boardMat = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
    const boardMesh = new THREE.Mesh(boardGeo, boardMat);
    scene.add(boardMesh);

    const footRadius = 0.12; // slightly bigger so it doesn't clip into board
    // Feet positioned slightly above the board surface (board at y=1 with height 0.05)
    const frontFootBody = new CANNON.Body({
      mass: 0.5,
      shape: new CANNON.Sphere(footRadius),
      position: new CANNON.Vec3(0, 1 + 0.025 + footRadius, 1.4),
      linearDamping: 0.9,
      angularDamping: 0.9,
    });
    const backFootBody = new CANNON.Body({
      mass: 0.5,
      shape: new CANNON.Sphere(footRadius),
      position: new CANNON.Vec3(0, 1 + 0.025 + footRadius, -1.4),
      linearDamping: 0.9,
      angularDamping: 0.9,
    });
    world.addBody(frontFootBody);
    world.addBody(backFootBody);

    const footGeo = new THREE.SphereGeometry(footRadius, 32, 32);
    const frontFootMesh = new THREE.Mesh(
      footGeo,
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    const backFootMesh = new THREE.Mesh(
      footGeo,
      new THREE.MeshStandardMaterial({ color: 0x0000ff })
    );
    scene.add(frontFootMesh);
    scene.add(backFootMesh);

    // Constraints attach feet to board tails
    const frontConstraint = new CANNON.PointToPointConstraint(
      boardBody,
      new CANNON.Vec3(0, 0, 1.4),
      frontFootBody,
      new CANNON.Vec3(0, 0, 0)
    );
    const backConstraint = new CANNON.PointToPointConstraint(
      boardBody,
      new CANNON.Vec3(0, 0, -1.4),
      backFootBody,
      new CANNON.Vec3(0, 0, 0)
    );
    world.addConstraint(frontConstraint);
    world.addConstraint(backConstraint);

    function handleGamepadInput() {
      const gamepads = navigator.getGamepads();
      if (!gamepads || !gamepads[0]) return;

      const gp = gamepads[0];

      const leftX = gp.axes[0];
      const leftY = gp.axes[1];
      const rightX = gp.axes[2];
      const rightY = gp.axes[3];

      const footForce = 10;

      if (Math.abs(leftX) > 0.1 || Math.abs(leftY) > 0.1) {
        backFootBody.applyForce(
          new CANNON.Vec3(leftX * footForce, 0, -leftY * footForce),
          backFootBody.position
        );
      }
      if (Math.abs(rightX) > 0.1 || Math.abs(rightY) > 0.1) {
        frontFootBody.applyForce(
          new CANNON.Vec3(rightX * footForce, 0, -rightY * footForce),
          frontFootBody.position
        );
      }
    }

    camera.position.set(0, 3, 7);
    camera.lookAt(0, 1, 0);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const camTarget = new THREE.Vector3();
    const camOffset = new THREE.Vector3(0, 3, 6);

    function animate() {
      requestAnimationFrame(animate);

      world.step(1 / 60);
      handleGamepadInput();

      boardMesh.position.copy(boardBody.position);
      boardMesh.quaternion.copy(boardBody.quaternion);

      frontFootMesh.position.copy(frontFootBody.position);
      frontFootMesh.quaternion.copy(frontFootBody.quaternion);

      backFootMesh.position.copy(backFootBody.position);
      backFootMesh.quaternion.copy(backFootBody.quaternion);

      // Smooth camera follow: position camera behind and above the board, looking at it
      camTarget.copy(boardMesh.position);
      let offset = camOffset.clone().applyQuaternion(boardMesh.quaternion);
      camera.position.lerp(boardMesh.position.clone().add(offset), 0.1);
      camera.lookAt(camTarget);

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
