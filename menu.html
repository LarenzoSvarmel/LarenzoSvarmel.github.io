<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skateboard Physics with Three.js & Cannon-es</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);

const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

const groundMaterial = new CANNON.Material('ground');
const groundBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane(),
  material: groundMaterial,
});
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

const groundGeo = new THREE.PlaneGeometry(100, 100);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
const groundMesh = new THREE.Mesh(groundGeo, groundMat);
groundMesh.rotation.x = -Math.PI / 2;
scene.add(groundMesh);

const boardShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.025, 1.5));
const boardBody = new CANNON.Body({
  mass: 2,
  shape: boardShape,
  position: new CANNON.Vec3(0, 1, 0),
});
boardBody.quaternion.setFromEuler(0, 0, 0);
world.addBody(boardBody);

const boardGeo = new THREE.BoxGeometry(1, 0.05, 3);
const boardMat = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
const boardMesh = new THREE.Mesh(boardGeo, boardMat);
scene.add(boardMesh);

const footRadius = 0.12;
function createFoot(position) {
  const body = new CANNON.Body({
    mass: 0.5,
    shape: new CANNON.Sphere(footRadius),
    position: position.clone(),
    linearDamping: 0.9,
    angularDamping: 0.9,
  });
  world.addBody(body);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(footRadius, 32, 32),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
  );
  scene.add(mesh);

  return { body, mesh };
}

const frontFootStartPos = new CANNON.Vec3(0, 1 + 0.025 + footRadius, 1.4);
const backFootStartPos = new CANNON.Vec3(0, 1 + 0.025 + footRadius, -1.4);

const frontFoot = createFoot(frontFootStartPos);
const backFoot = createFoot(backFootStartPos);
backFoot.mesh.material.color.set(0x0000ff);

const frontConstraint = new CANNON.PointToPointConstraint(
  boardBody,
  new CANNON.Vec3(0, 0, 1.4),
  frontFoot.body,
  new CANNON.Vec3(0, 0, 0)
);
const backConstraint = new CANNON.PointToPointConstraint(
  boardBody,
  new CANNON.Vec3(0, 0, -1.4),
  backFoot.body,
  new CANNON.Vec3(0, 0, 0)
);
world.addConstraint(frontConstraint);
world.addConstraint(backConstraint);

// Foot control points relative to board local space
// front foot points: left edge, right edge, top (nose), bottom (pocket)
// back foot points mirrored (left/right swapped)
const footControlPoints = {
  front: {
    left: new THREE.Vector3(-0.5, 0, 1.5),
    right: new THREE.Vector3(0.5, 0, 1.5),
    top: new THREE.Vector3(0, 0, 1.5),
    bottom: new THREE.Vector3(0, 0, 1.1), // slightly behind nose, simulating pocket area
  },
  back: {
    left: new THREE.Vector3(0.5, 0, -1.5),  // mirrored: left = right edge
    right: new THREE.Vector3(-0.5, 0, -1.5),
    top: new THREE.Vector3(0, 0, -1.5),
    bottom: new THREE.Vector3(0, 0, -1.1),
  },
};

// State to track stick position and foot pressed state
let leftStickPos = new THREE.Vector2(0,0);
let rightStickPos = new THREE.Vector2(0,0);
let leftStickActive = false;
let rightStickActive = false;

// Function to get closest control point from stick input for each foot
function getFootTargetPoint(foot, stickPos) {
  // stickPos x,y in range -1 to 1, center is (0,0)
  // We'll interpret y = forward/back, x = left/right

  // For front foot, positive y moves towards "top" (nose), negative y towards "bottom" (pocket)
  // For back foot, same but mirrored left/right

  // Determine dominant horizontal direction (left/right)
  let horiz = stickPos.x;
  let vert = stickPos.y;

  // Clamp length so we don't get crazy positions
  const deadzone = 0.2;
  if (stickPos.length() < deadzone) return null; // no movement

  // Choose vertical point: if vert > 0 => top, else bottom
  const verticalPointName = vert > 0 ? 'top' : 'bottom';

  // Choose horizontal point: if horiz < 0 => left, else right
  const horizontalPointName = horiz < 0 ? 'left' : 'right';

  // Interpolate between horizontal and vertical points weighted by magnitude of horiz and vert
  const absHoriz = Math.abs(horiz);
  const absVert = Math.abs(vert);
  const total = absHoriz + absVert;

  // If total is zero, no move
  if(total === 0) return null;

  const vertWeight = absVert / total;
  const horizWeight = absHoriz / total;

  const footPoints = footControlPoints[foot];
  // Weighted average of horizontal and vertical points
  const target = new THREE.Vector3();
  target.copy(footPoints[verticalPointName]).multiplyScalar(vertWeight);
  target.addScaledVector(footPoints[horizontalPointName], horizWeight);

  return target;
}

// Update feet position based on sticks
function updateFeetPositions() {
  // front foot controlled by right stick
  if (rightStickActive) {
    const localTarget = getFootTargetPoint('front', rightStickPos);
    if(localTarget) {
      // Convert from board local to world
      const boardPos = new THREE.Vector3().copy(boardBody.position);
      const quat = new THREE.Quaternion().copy(boardBody.quaternion);
      const worldTarget = localTarget.clone().applyQuaternion(quat).add(boardPos);

      // Raise foot slightly above board surface
      worldTarget.y = boardBody.position.y + 0.025 + footRadius + 0.02;

      // Move front foot toward target smoothly (to avoid spazzing)
      frontFoot.body.position.lerp(new CANNON.Vec3(worldTarget.x, worldTarget.y, worldTarget.z), 0.15);
      frontFoot.body.velocity.set(0, 0, 0);
      frontFoot.body.angularVelocity.set(0, 0, 0);
    }
  }

  // back foot controlled by left stick
  if (leftStickActive) {
    const localTarget = getFootTargetPoint('back', leftStickPos);
    if(localTarget) {
      const boardPos = new THREE.Vector3().copy(boardBody.position);
      const quat = new THREE.Quaternion().copy(boardBody.quaternion);
      const worldTarget = localTarget.clone().applyQuaternion(quat).add(boardPos);

      worldTarget.y = boardBody.position.y + 0.025 + footRadius + 0.02;

      backFoot.body.position.lerp(new CANNON.Vec3(worldTarget.x, worldTarget.y, worldTarget.z), 0.15);
      backFoot.body.velocity.set(0, 0, 0);
      backFoot.body.angularVelocity.set(0, 0, 0);
    }
  }
}

// On stick release, "pop" the board and "jump" feet off the board
function onStickRelease(foot) {
  const footObj = foot === 'front' ? frontFoot : backFoot;

  // Remove constraint for that foot so it can "jump" off
  if (foot === 'front' && world.constraints.includes(frontConstraint)) {
    world.removeConstraint(frontConstraint);
  }
  if (foot === 'back' && world.constraints.includes(backConstraint)) {
    world.removeConstraint(backConstraint);
  }

  // Calculate impulse for feet: upwards and slightly outwards from board center
  const impulseStrength = 3;
  // Direction vector from board center to foot
  const dir = new CANNON.Vec3().copy(footObj.body.position).vsub(boardBody.position);
  dir.y = 0;
  dir.normalize();

  // Apply impulse upward and outward
  const impulse = new CANNON.Vec3(dir.x * impulseStrength * 0.5, impulseStrength, dir.z * impulseStrength * 0.5);
  footObj.body.applyImpulse(impulse, footObj.body.position);

  // Apply opposite impulse to board to simulate pop
  const boardImpulse = impulse.scale(-0.5);
  boardBody.applyImpulse(boardImpulse, boardBody.position);

  // After ~1.2 seconds, land feet back onto board and re-add constraint
  setTimeout(() => {
    // Snap foot above board at default position
    let localPos = foot === 'front' ? frontFootStartPos : backFootStartPos;
    footObj.body.position.set(localPos.x, localPos.y, localPos.z);
    footObj.body.velocity.set(0, 0, 0);
    footObj.body.angularVelocity.set(0, 0, 0);

    // Re-add constraint if missing
    if (foot === 'front' && !world.constraints.includes(frontConstraint)) {
      world.addConstraint(frontConstraint);
    }
    if (foot === 'back' && !world.constraints.includes(backConstraint)) {
      world.addConstraint(backConstraint);
    }
  }, 1200);
}

// Input handling (Gamepad + keyboard for demo)
window.addEventListener('gamepadconnected', (e) => {
  console.log('Gamepad connected:', e.gamepad);
});

function pollGamepads() {
  const gp = navigator.getGamepads()[0];
  if (!gp) {
    leftStickActive = false;
    rightStickActive = false;
    return;
  }
  // Left stick controls back foot
  leftStickPos.set(gp.axes[0], -gp.axes[1]);
  leftStickActive = leftStickPos.length() > 0.2;

  // Right stick controls front foot
  rightStickPos.set(gp.axes[2], -gp.axes[3]);
  rightStickActive = rightStickPos.length() > 0.2;

  // Detect stick release: if stick was active but now below deadzone, trigger release event
  if (leftStickActive === false && leftStickLastActive) {
    onStickRelease('back');
  }
  if (rightStickActive === false && rightStickLastActive) {
    onStickRelease('front');
  }

  leftStickLastActive = leftStickActive;
  rightStickLastActive = rightStickActive;
}

let leftStickLastActive = false;
let rightStickLastActive = false;

// Keyboard fallback for testing: arrows = back foot, WASD = front foot
const keyState = {};
window.addEventListener('keydown', (e) => { keyState[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', (e) => { keyState[e.key.toLowerCase()] = false; });

function updateKeyboardSticks() {
  // Back foot - arrows
  let lx = 0, ly = 0;
  if (keyState['arrowleft']) lx = -1;
  else if (keyState['arrowright']) lx = 1;
  if (keyState['arrowup']) ly = 1;
  else if (keyState['arrowdown']) ly = -1;
  leftStickPos.set(lx, ly);
  leftStickActive = leftStickPos.length() > 0;

  // Front foot - WASD
  let rx = 0, ry = 0;
  if (keyState['a']) rx = -1;
  else if (keyState['d']) rx = 1;
  if (keyState['w']) ry = 1;
  else if (keyState['s']) ry = -1;
  rightStickPos.set(rx, ry);
  rightStickActive = rightStickPos.length() > 0;

  // Detect releases for keyboard too
  if (!leftStickActive && leftStickLastActive) {
    onStickRelease('back');
  }
  if (!rightStickActive && rightStickLastActive) {
    onStickRelease('front');
  }

  leftStickLastActive = leftStickActive;
  rightStickLastActive = rightStickActive;
}

camera.position.set(0, 3, 7);
camera.lookAt(0, 1, 0);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

const camTarget = new THREE.Vector3();
const camOffset = new THREE.Vector3(0, 3, 6);

function animate() {
  requestAnimationFrame(animate);

  pollGamepads();
  updateKeyboardSticks();
  updateFeetPositions();

  world.step(1 / 60);

  boardMesh.position.copy(boardBody.position);
  boardMesh.quaternion.copy(boardBody.quaternion);

  frontFoot.mesh.position.copy(frontFoot.body.position);
  frontFoot.mesh.quaternion.copy(frontFoot.body.quaternion);

  backFoot.mesh.position.copy(backFoot.body.position);
  backFoot.mesh.quaternion.copy(backFoot.body.quaternion);

  camTarget.copy(boardMesh.position);
  let offset = camOffset.clone().applyQuaternion(boardMesh.quaternion);
  camera.position.lerp(boardMesh.position.clone().add(offset), 0.1);
  camera.lookAt(camTarget);

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
