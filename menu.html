<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Skateboard Physics with FBX Model + Ollie</title>
  <style>
    body { margin: 0; overflow: hidden; background: #202030; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #ddd; font-family: monospace; user-select:none;
      background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;
    }
  </style>
</head>
<body>
<div id="info">
  Left Stick = Back Foot Control (Push/Pull)<br>
  Right Stick = Front Foot Control (Push/Pull)<br>
  Stance: Normal (regular) or Switch (reverse)<br>
  Ollie by pressing Space or flicking right stick up<br>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/FBXLoader.js"></script>

<script>
  let scene, camera, renderer;
  let board;
  let velocity = new THREE.Vector3();
  const gravity = -9.8;
  let onGround = true;
  let isOllie = false;
  let ollieTimer = 0;
  const ollieDuration = 0.5;

  // Skate stance: true = regular, false = switch
  let isRegularStance = true;

  // Gamepad support
  let gamepadIndex = null;
  let lastRightStickY = 0;
  const flickThreshold = 0.7;
  let flickCooldown = 0;

  const clock = new THREE.Clock();

  init();
  animate();

  function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202030);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Ground plane
    const groundMat = new THREE.MeshStandardMaterial({color: 0x444455});
    const groundGeom = new THREE.PlaneGeometry(100, 100);
    const ground = new THREE.Mesh(groundGeom, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Load FBX skateboard using raw.githubusercontent.com URL
    const loader = new THREE.FBXLoader();
    loader.load(
      'https://raw.githubusercontent.com/LarenzoSvarmel/LarenzoSvarmel.github.io/main/untitled.fbx',
      function(object){
        board = object;
        board.scale.set(0.01, 0.01, 0.01);
        board.position.y = 0.2;

        // Fix materials and textures
        board.traverse((child) => {
          if(child.isMesh){
            child.castShadow = true;
            child.receiveShadow = true;
            child.material.side = THREE.DoubleSide;
            if(child.material.map){
              child.material.map.encoding = THREE.sRGBEncoding;
              child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
              child.material.map.needsUpdate = true;
            }
            child.material.needsUpdate = true;
          }
        });

        scene.add(board);
      },
      undefined,
      function(error){
        console.error('Error loading FBX:', error);
      }
    );

    // Input listeners
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    window.addEventListener("gamepadconnected", (e) => {
      gamepadIndex = e.gamepad.index;
      console.log("Gamepad connected at index", gamepadIndex);
    });
    window.addEventListener("gamepaddisconnected", (e) => {
      if(e.gamepad.index === gamepadIndex) gamepadIndex = null;
      console.log("Gamepad disconnected");
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }

  const keys = {};

  function onKeyDown(e){
    keys[e.code] = true;

    if(e.code === 'Space' && onGround && !isOllie){
      startOllie();
    }

    // Toggle stance with 'KeyQ'
    if(e.code === 'KeyQ'){
      isRegularStance = !isRegularStance;
      console.log('Stance:', isRegularStance ? 'Regular' : 'Switch');
    }
  }

  function onKeyUp(e){
    keys[e.code] = false;
  }

  function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if(!board) {
      renderer.render(scene, camera);
      return;
    }

    // === Input processing ===

    // Keyboard velocity & rotation
    if(keys['KeyW']){
      velocity.z -= 10 * delta;
    } else if(keys['KeyS']){
      velocity.z += 8 * delta;
    } else {
      velocity.z *= 0.95;
    }

    if(keys['KeyA']){
      board.rotation.y += 2 * delta;
    }
    if(keys['KeyD']){
      board.rotation.y -= 2 * delta;
    }

    // Gamepad input
    if(gamepadIndex !== null){
      const gp = navigator.getGamepads()[gamepadIndex];
      if(gp){
        // Left stick = back foot control (push/pull)
        let lx = gp.axes[0];
        let ly = gp.axes[1];

        // Right stick = front foot control (push/pull)
        let rx = gp.axes[2];
        let ry = gp.axes[3];

        // Velocity based on left stick Y
        if(Math.abs(ly) > 0.2){
          velocity.z -= ly * 10 * delta;
        } else {
          velocity.z *= 0.95;
        }

        // Rotation based on left stick X
        if(Math.abs(lx) > 0.2){
          board.rotation.y -= lx * 2 * delta;
        }

        // Detect right stick flick UP for ollie
        if(flickCooldown <= 0){
          if(lastRightStickY > -flickThreshold && ry <= -flickThreshold && onGround && !isOllie){
            startOllie();
            flickCooldown = 0.3;
          }
        }
        lastRightStickY = ry;

        if(flickCooldown > 0){
          flickCooldown -= delta;
        }
      }
    }

    // === Ollie physics ===
    if(isOllie){
      ollieTimer += delta;
      const ollieHeight = 1.5;
      const t = ollieTimer / ollieDuration;
      const height = ollieHeight * 4 * t * (1 - t);
      board.position.y = 0.2 + height;

      if(ollieTimer >= ollieDuration){
        isOllie = false;
        ollieTimer = 0;
        board.position.y = 0.2;
        velocity.y = 0;
        onGround = true;
      }
    } else {
      velocity.y += gravity * delta;
      board.position.y += velocity.y * delta;
      if(board.position.y < 0.2){
        board.position.y = 0.2;
        velocity.y = 0;
        onGround = true;
      }
    }

    // Move skateboard
    board.position.x += Math.sin(board.rotation.y) * velocity.z * delta;
    board.position.z += Math.cos(board.rotation.y) * velocity.z * delta;

    // Smooth camera follow
    const cameraTargetOffset = new THREE.Vector3(0, 2.5, -6);
    const cameraLookAtOffset = new THREE.Vector3(0, 1.2, 0);
    const desiredCamPos = board.position.clone().add(cameraTargetOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), board.rotation.y));
    camera.position.lerp(desiredCamPos, 0.1);
    const lookAtPos = board.position.clone().add(cameraLookAtOffset);
    camera.lookAt(lookAtPos);

    renderer.render(scene, camera);
  }

  function startOllie(){
    isOllie = true;
    ollieTimer = 0;
    onGround = false;
    velocity.y = 5;
  }
</script>
</body>
</html>
