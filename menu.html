<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dual Stick Skateboard Physics</title>
  <style>
    body { margin: 0; overflow: hidden; background: #202030; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #ddd; font-family: monospace; user-select:none;
      background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;
    }
  </style>
</head>
<body>
<div id="info">Left Stick = Tail, Right Stick = Nose</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202030);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 5, 10);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Ground
  const groundMat = new THREE.MeshStandardMaterial({color: 0x444455});
  const groundGeom = new THREE.PlaneGeometry(100, 100);
  const ground = new THREE.Mesh(groundGeom, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Skateboard
  const boardMat = new THREE.MeshStandardMaterial({color: 0xffcc00});
  const boardGeom = new THREE.BoxGeometry(3, 0.1, 1);
  const board = new THREE.Mesh(boardGeom, boardMat);
  board.position.set(0, 0.2, 0);
  board.rotation.y = 0; // facing +Z
  scene.add(board);

  // Physics state
  let velocity = new THREE.Vector3(0, 0, 0);
  let angularVelocity = 0; // for simplicity, rotation around Y-axis only
  const gravity = -9.8;

  // Gamepad
  let gamepadIndex = null;
  window.addEventListener("gamepadconnected", (e) => {
    gamepadIndex = e.gamepad.index;
    console.log("Gamepad connected at index", gamepadIndex);
  });
  window.addEventListener("gamepaddisconnected", (e) => {
    if(e.gamepad.index === gamepadIndex) gamepadIndex = null;
    console.log("Gamepad disconnected");
  });

  // Clock
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    // Control params
    const torqueStrength = 5;
    const thrust = 8;

    // Input
    let noseInput = {x: 0, y: 0};
    let tailInput = {x: 0, y: 0};

    if (gamepadIndex !== null) {
      const gp = navigator.getGamepads()[gamepadIndex];
      if (gp) {
        tailInput.x = gp.axes[0]; // Left stick X
        tailInput.y = gp.axes[1]; // Left stick Y
        noseInput.x = gp.axes[2]; // Right stick X
        noseInput.y = gp.axes[3]; // Right stick Y
      }
    }

    // Compute direction vectors based on board rotation
    const forward = new THREE.Vector3(Math.sin(board.rotation.y), 0, Math.cos(board.rotation.y));
    const right = new THREE.Vector3(forward.z, 0, -forward.x);

    // Tail and nose positions relative to board center
    const halfLength = 1.5;
    const tailPos = board.position.clone().add(forward.clone().multiplyScalar(-halfLength));
    const nosePos = board.position.clone().add(forward.clone().multiplyScalar(halfLength));

    // Apply forces based on stick input
    const tailForce = forward.clone().multiplyScalar(-tailInput.y * thrust);
    const noseForce = forward.clone().multiplyScalar(-noseInput.y * thrust);

    // Update linear velocity
    const netForce = tailForce.clone().add(noseForce);
    velocity.add(netForce.multiplyScalar(delta));

    // Apply torque: difference between tail and nose lateral pushes
    const torque = (noseInput.x - tailInput.x) * torqueStrength;
    angularVelocity += torque * delta;

    // Apply drag
    velocity.multiplyScalar(0.98);
    angularVelocity *= 0.96;

    // Update position and rotation
    board.position.add(velocity.clone().applyAxisAngle(new THREE.Vector3(0,1,0), board.rotation.y).multiplyScalar(delta));
    board.rotation.y += angularVelocity * delta;

    // Gravity
    velocity.y += gravity * delta;
    board.position.y += velocity.y * delta;
    if (board.position.y < 0.2) {
      board.position.y = 0.2;
      velocity.y = 0;
    }

    // Camera follow
    const cameraTargetOffset = new THREE.Vector3(0, 2.5, -6).applyAxisAngle(new THREE.Vector3(0, 1, 0), board.rotation.y);
    const desiredCamPos = board.position.clone().add(cameraTargetOffset);
    camera.position.lerp(desiredCamPos, 0.1);
    const lookAtPos = board.position.clone().add(new THREE.Vector3(0, 1.2, 0));
    camera.lookAt(lookAtPos);

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
