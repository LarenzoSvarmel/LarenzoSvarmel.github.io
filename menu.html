<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Terrain Generator/Builder</title>
  <style>
    body, html { margin: 0; overflow: hidden; height: 100%; }
    canvas { display: block; }
    #ui {
      position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6);
      color: white; padding: 10px; border-radius: 10px; font-family: sans-serif;
    }
    #ui label, #ui input, #ui button, #ui select { display: block; margin: 5px 0; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Hill Height: <input type="range" id="hillHeight" min="0" max="100" value="30" /></label>
    <label>Dip Depth: <input type="range" id="dipDepth" min="0" max="100" value="20" /></label>
    <label>Foliage Density: <input type="range" id="foliageDensity" min="0" max="100" value="50" /></label>
    <label>Ground Texture: 
      <select id="groundTexture">
        <option value="sand">Sand</option>
        <option value="grass">Grass</option>
      </select>
    </label>
    <button id="exportBtn">Export Terrain Data</button>
    <input type="file" id="importInput" />
  </div>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three';
    import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';

    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    camera.position.set(0, 40, 100);
    controls.update();

    const terrainSize = 128;
    const geometry = new THREE.PlaneGeometry(100, 100, terrainSize - 1, terrainSize - 1);
    geometry.rotateX(-Math.PI / 2);

    const loader = new THREE.TextureLoader();
    const textures = {
      sand: loader.load('https://upload.wikimedia.org/wikipedia/commons/7/7a/Sand_texture.jpg'),
      grass: loader.load('https://upload.wikimedia.org/wikipedia/commons/b/be/Grass_texture.jpg'),
    };

    const material = new THREE.MeshStandardMaterial({map: textures.grass});
    const terrain = new THREE.Mesh(geometry, material);
    scene.add(terrain);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    function regenerateTerrain() {
      const hills = parseFloat(document.getElementById('hillHeight').value);
      const dips = parseFloat(document.getElementById('dipDepth').value);
      for (let i = 0; i < geometry.attributes.position.count; i++) {
        const x = i % terrainSize;
        const y = Math.floor(i / terrainSize);
        const dx = (x - terrainSize / 2) / terrainSize;
        const dy = (y - terrainSize / 2) / terrainSize;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const height = Math.sin(dist * Math.PI * 4) * hills / 10 - Math.cos(dist * Math.PI * 3) * dips / 10;
        geometry.attributes.position.setY(i, height);
      }
      geometry.attributes.position.needsUpdate = true;
      geometry.computeVertexNormals();
    }

    document.getElementById('hillHeight').oninput = regenerateTerrain;
    document.getElementById('dipDepth').oninput = regenerateTerrain;
    document.getElementById('groundTexture').oninput = (e) => {
      material.map = textures[e.target.value];
      material.needsUpdate = true;
    };

    document.getElementById('exportBtn').onclick = () => {
      const data = geometry.attributes.position.array;
      const blob = new Blob([JSON.stringify(Array.from(data))], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'terrain.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById('importInput').onchange = (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        const arr = JSON.parse(reader.result);
        for (let i = 0; i < arr.length; i++) {
          geometry.attributes.position.array[i] = arr[i];
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();
      };
      reader.readAsText(file);
    };

    regenerateTerrain();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
